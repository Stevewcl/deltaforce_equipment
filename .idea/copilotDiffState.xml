<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;三角洲倒子弹脚本&#10;功能：通过高频刷新交易行界面监控装备价格，截取低价装备购买&#10;作者：wcl&#10;最后更新：2025.8.20&#10;&quot;&quot;&quot;&#10;import mss&#10;import numpy as np&#10;import win32gui&#10;import win32process&#10;import psutil&#10;import win32con&#10;from PIL import ImageDraw&#10;import detect_money&#10;import detect_location&#10;import threading&#10;import queue&#10;import time&#10;import schedule&#10;import configparser&#10;import pyautogui&#10;import pytesseract&#10;import os&#10;import sys&#10;import datetime&#10;import keyboard&#10;from dataclasses import dataclass&#10;from mouse_keyboard_controller import MouseKeyboardController&#10;&#10;controller = MouseKeyboardController()&#10;&#10;# 获取脚本所在目录&#10;BASE_DIR = os.path.dirname(os.path.abspath(__file__))&#10;# 使用相对路径读取配置文件&#10;config_path = os.path.join(BASE_DIR, 'config.ini')&#10;&#10;config = configparser.ConfigParser()&#10;# 显式指定 UTF-8 编码来读取文件&#10;with open(config_path, encoding='utf-8') as f:&#10;    config.read_file(f)&#10;&#10;# --- 配置参数 ---&#10;game_name = config['window']['game_window_name']  # 游戏窗口名称&#10;min_width = int(config['window']['min_width'])  # 最小窗口宽度&#10;min_height = int(config['window']['min_height'])  # 最小窗口高度&#10;expected_price = config['limit']['expected_price'].split(',')&#10;expected_price_1 = int(expected_price[0])  # 价格下限&#10;expected_price_2 = int(expected_price[1])  # 价格上限&#10;x = int(config['click_location']['x'])  # 收藏物品X坐标&#10;y = int(config['click_location']['y'])  # 收藏物品Y坐标&#10;execution_time = config['schedule']['execution_time']  # 脚本执行时间&#10;execution_time_single = int(config['schedule']['execution_time_single'])  # 单次执行时长(秒)&#10;duration = int(config['schedule']['duration'])  # 总运行时长(秒)&#10;&#10;# --- 控制标志 ---&#10;paused = False  # 控制脚本暂停/恢复&#10;should_exit = False  # 标记主程序的运行与结束&#10;thread_pause_click = False  # 控制连点线程的暂停&#10;thread_running = True  # 控制主程序运行与结束时子线程的运行与结束&#10;game_window_hwnd = None  # 游戏主窗口句柄&#10;&#10;# --- 线程通信 ---&#10;color_check_result = False  # 线程安全变量，存储颜色检测结果&#10;color_check_lock = threading.Lock()  # 颜色检测结果的线程锁&#10;&#10;# --- 统计数据 ---&#10;start_time_single = time.time()  # 计时器初始值&#10;consumption = initial_money = end_money = 0  # 消耗的哈夫币统计&#10;&#10;&#10;class Tee:&#10;    &quot;&quot;&quot;&#10;    同时将输出重定向到控制台和日志文件的类&#10;&#10;    实现了标准输出的重定向，同时捕获未处理的异常并记录到日志文件&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, filename=None):&#10;        &quot;&quot;&quot;&#10;        初始化Tee对象，设置日志文件路径并重定向标准输出&#10;&#10;        参数:&#10;            filename: str - 日志文件名，如果为None则使用当前时间戳命名&#10;        &quot;&quot;&quot;&#10;        log_dir = os.path.join(BASE_DIR, 'logs')  # 指定日志保存路径&#10;        os.makedirs(log_dir, exist_ok=True)  # 确保目录存在&#10;&#10;        # 如果没有提供文件名，则以当前时间命名&#10;        if filename is None:&#10;            timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d_%H-%M-%S&quot;)&#10;            filename = f&quot;log_{timestamp}.txt&quot;&#10;&#10;        self.file = open(os.path.join(log_dir, filename), &quot;a&quot;, encoding=&quot;utf-8&quot;)  # 追加模式&#10;        self.stdout = sys.stdout&#10;        sys.stdout = self&#10;&#10;        # 设置异常钩子，捕获未处理的异常&#10;        self.original_excepthook = sys.excepthook&#10;        sys.excepthook = self.exception_handler&#10;&#10;    def write(self, message):&#10;        &quot;&quot;&quot;&#10;        写入消息到标准输出和日志文件&#10;&#10;        参数:&#10;            message: str - 要写入的消息&#10;        &quot;&quot;&quot;&#10;        # 获取当前时间戳，精确到毫秒&#10;        timestamp = f&quot;[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]}] &quot;&#10;        # 在每条日志前添加时间戳&#10;        if message.strip():  # 仅对非空行添加时间戳&#10;            message = f&quot;{timestamp}{message}&quot;  # 确保时间戳格式完整&#10;        self.stdout.write(message)  # 在 CMD 窗口打印&#10;        self.file.write(message)  # 同时写入文件&#10;        self.flush()  # 确保日志信息立即写入文件&#10;&#10;    def flush(self):&#10;        &quot;&quot;&quot;确保日志即时写入文件和标准输出&quot;&quot;&quot;&#10;        self.stdout.flush()&#10;        self.file.flush()&#10;&#10;    def exception_handler(self, exc_type, exc_value, exc_traceback):&#10;        &quot;&quot;&quot;&#10;        处理未捕获的异常，将异常信息记录到日志文件&#10;&#10;        参数:&#10;            exc_type: 异常类型&#10;            exc_value: 异常值&#10;            exc_traceback: 异常的堆栈跟踪&#10;        &quot;&quot;&quot;&#10;        # 将异常信息格式化为字符串&#10;        import traceback&#10;        exception_str = &quot;&quot;.join(traceback.format_exception(exc_type, exc_value, exc_traceback))&#10;        # 写入日志&#10;        self.write(&quot;\n*** 捕获到未处理的异常 ***\n&quot;)&#10;        self.write(f&quot;{exception_str}\n&quot;)&#10;        self.write(&quot;*** 异常信息结束 ***\n&quot;)&#10;        self.flush()&#10;        # 调用原始异常处理器&#10;        self.original_excepthook(exc_type, exc_value, exc_traceback)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class PurchaseEvent:&#10;    kind: str              # 'six_digits' | 'no_items' | 'seven_sep'&#10;    data: int | None = None&#10;&#10;class PurchaseStateMonitor:&#10;    &quot;&quot;&quot;&#10;    并行监测三种状态，任一命中产生事件；随后进入失效态，&#10;    待检测到“三种状态均不命中”连续 N 次后再重武装。&#10;    &quot;&quot;&quot;&#10;    def __init__(self, poll_interval: float = 0.03, rearm_clear_consecutive: int = 1):&#10;        self.poll_interval = poll_interval&#10;        self.rearm_clear_consecutive = rearm_clear_consecutive&#10;&#10;        self._stop = threading.Event()&#10;        self._armed = True&#10;        self._armed_lock = threading.Lock()&#10;&#10;        self._present = {'six': False, 'no': False, 'seven': False}&#10;        self._present_lock = threading.Lock()&#10;&#10;        self._q: &quot;queue.Queue[PurchaseEvent]&quot; = queue.Queue(maxsize=1)&#10;        self._threads: list[threading.Thread] = []&#10;&#10;    def start(self):&#10;        self._threads = [&#10;            threading.Thread(target=self._watch_six_digits, daemon=True),&#10;            threading.Thread(target=self._watch_no_items, daemon=True),&#10;            threading.Thread(target=self._watch_seven_sep, daemon=True),&#10;            threading.Thread(target=self._watch_rearm_all_clear, daemon=True),&#10;        ]&#10;        for t in self._threads:&#10;            t.start()&#10;&#10;    def stop(self):&#10;        self._stop.set()&#10;        for t in self._threads:&#10;            t.join(timeout=1.0)&#10;&#10;    def get_event(self, timeout: float | None = None) -&gt; PurchaseEvent:&#10;        return self._q.get(timeout=timeout)&#10;&#10;&#10;    def clear_pending(self) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        清空待处理事件，避免消费到上一次循环的残留事件。&#10;        采用与投递相同的锁以避免竞态。&#10;        &quot;&quot;&quot;&#10;        with self._armed_lock:&#10;            while True:&#10;                try:&#10;                    self._q.get_nowait()&#10;                except queue.Empty:&#10;                    break&#10;    def _emit_if_armed(self, evt: PurchaseEvent) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        若当前处于武装态，投递事件并转入失效态；返回 True 表示成功投递（可打印一次性日志）。&#10;        &quot;&quot;&quot;&#10;        with self._armed_lock:&#10;            if not self._armed:&#10;                return False&#10;            # 清理可能残留的旧事件，确保只保留最新命中的&#10;            while not self._q.empty():&#10;                try:&#10;                    self._q.get_nowait()&#10;                except queue.Empty:&#10;                    break&#10;            self._q.put(evt)&#10;            self._armed = False&#10;            return True&#10;&#10;    def _watch_six_digits(self):&#10;        while not self._stop.is_set():&#10;            val = detect_money.main()&#10;            hit = isinstance(val, int) and 100000 &lt;= val &lt;= 999999&#10;            with self._present_lock:&#10;                self._present['six'] = hit&#10;            if hit:&#10;                self._emit_if_armed(PurchaseEvent('six_digits', val))&#10;            time.sleep(self.poll_interval)&#10;&#10;    def _watch_no_items(self):&#10;        while not self._stop.is_set():&#10;            hit = is_color_similar(1630, 889, (75, 79, 82), 10)&#10;            with self._present_lock:&#10;                self._present['no'] = hit&#10;            if hit:&#10;                self._emit_if_armed(PurchaseEvent('no_items', None))&#10;            time.sleep(self.poll_interval)&#10;&#10;    def _watch_seven_sep(self):&#10;        while not self._stop.is_set():&#10;            hit = is_color_similar(313, 193, (179, 181, 183), 10)&#10;            with self._present_lock:&#10;                self._present['seven'] = hit&#10;            if hit:&#10;                self._emit_if_armed(PurchaseEvent('seven_sep', None))&#10;            time.sleep(self.poll_interval)&#10;&#10;    def _watch_rearm_all_clear(self):&#10;        clear_cnt = 0&#10;        while not self._stop.is_set():&#10;            with self._armed_lock:&#10;                armed = self._armed&#10;            if armed:&#10;                clear_cnt = 0&#10;                time.sleep(self.poll_interval)&#10;                continue&#10;&#10;            with self._present_lock:&#10;                any_hit = self._present['six'] or self._present['no'] or self._present['seven']&#10;&#10;            if not any_hit:&#10;                clear_cnt += 1&#10;                if clear_cnt &gt;= self.rearm_clear_consecutive:&#10;                    with self._armed_lock:&#10;                        self._armed = True&#10;                    clear_cnt = 0&#10;            else:&#10;                clear_cnt = 0&#10;            time.sleep(self.poll_interval)&#10;&#10;&#10;def take_screenshot(price):&#10;    &quot;&quot;&quot;&#10;    截取当前屏幕并保存，包含鼠标指针位置&#10;&#10;    参数:&#10;        price: int - 当前识别到的价格，将添加到文件名中&#10;&#10;    功能:&#10;        1. 创建包含时间戳和价格的文件名&#10;        2. 截取全屏&#10;        3. 在截图上标记当前鼠标位置&#10;        4. 保存截图到指定目录&#10;    &quot;&quot;&quot;&#10;    # 获取当前时间戳，精确到毫秒&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d_%H-%M-%S.%f&quot;)[:-3]&#10;    # 将价格添加到文件名中&#10;    screenshot_path = os.path.join(BASE_DIR, 'screenshots', f&quot;screenshot_{timestamp}_price_{price}.png&quot;)&#10;    os.makedirs(os.path.dirname(screenshot_path), exist_ok=True)  # 确保目录存在&#10;&#10;    # 使用pyautogui截取全屏&#10;    screenshot = pyautogui.screenshot()&#10;&#10;    # 获取鼠标位置，用于在截图上标记鼠标位置&#10;    cursor_pos = win32gui.GetCursorPos()&#10;&#10;    # 获取当前使用的鼠标光标&#10;    cursor_info = win32gui.GetCursorInfo()&#10;    cursor = cursor_info[1]  # 获取光标句柄&#10;&#10;    # 获取光标信息&#10;    if cursor:&#10;        try:&#10;            # 将光标绘制到截图上&#10;            draw = ImageDraw.Draw(screenshot)&#10;&#10;            # 绘制一个红色圆点表示光标位置，便于后续分析问题&#10;            draw.ellipse((cursor_pos[0] - 2, cursor_pos[1] - 2,&#10;                          cursor_pos[0] + 2, cursor_pos[1] + 2), fill='red')&#10;&#10;        except Exception as e:&#10;            print(f&quot;无法添加鼠标指针: {str(e)}&quot;)&#10;&#10;    # 保存图片&#10;    screenshot.save(screenshot_path)&#10;    print(f&quot;全屏幕截屏(含鼠标指针)已保存到 {screenshot_path}&quot;)&#10;&#10;&#10;def get_window_normal_size(hwnd):&#10;    &quot;&quot;&quot;&#10;    获取窗口的正常尺寸，即使它当前是最小化的&#10;&#10;    参数:&#10;        hwnd: int - 窗口句柄&#10;&#10;    返回:&#10;        tuple: (width, height) - 窗口的宽度和高度&#10;&#10;    功能:&#10;        1. 检查窗口是否最小化&#10;        2. 如果是最小化状态，获取其正常位置信息&#10;        3. 如果不是最小化状态，直接获取当前尺寸&#10;        4. 返回窗口的宽度和高度&#10;    &quot;&quot;&quot;&#10;    minimized = win32gui.IsIconic(hwnd)&#10;&#10;    if minimized:&#10;        # 获取窗口的正常位置信息（即使窗口是最小化的）&#10;        window_placement = win32gui.GetWindowPlacement(hwnd)&#10;        normal_rect = window_placement[4]  # normalPosition属性&#10;        width = normal_rect[2] - normal_rect[0]&#10;        height = normal_rect[3] - normal_rect[1]&#10;        return width, height&#10;    else:&#10;        # 窗口未最小化，直接获取当前尺寸&#10;        rect = win32gui.GetWindowRect(hwnd)&#10;        width = rect[2] - rect[0]&#10;        height = rect[3] - rect[1]&#10;        return width, height&#10;&#10;&#10;def find_game_window():&#10;    &quot;&quot;&quot;&#10;    查找游戏窗口，通过尺寸区分游戏本体和启动器&#10;&#10;    返回:&#10;        int: 游戏窗口句柄，若未找到则返回0&#10;&#10;    功能:&#10;        1. 枚举所有窗口，筛选出标题包含游戏名称的窗口&#10;        2. 获取这些窗口的尺寸和进程信息&#10;        3. 根据最小尺寸要求筛选出符合条件的窗口&#10;        4. 选择尺寸最大的窗口作为游戏主窗口&#10;    &quot;&quot;&quot;&#10;    global game_window_hwnd&#10;&#10;    windows = []&#10;&#10;    def callback(hwnd, extra):&#10;        if win32gui.IsWindowVisible(hwnd):&#10;            title = win32gui.GetWindowText(hwnd)&#10;            if game_name.lower() in title.lower():&#10;                # 获取窗口正常尺寸（即使最小化）&#10;                width, height = get_window_normal_size(hwnd)&#10;                # 获取进程信息&#10;                try:&#10;                    pid = win32process.GetWindowThreadProcessId(hwnd)[1]&#10;                    process = psutil.Process(pid)&#10;                    exe_path = process.exe()&#10;                    proc_name = process.name()&#10;                except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                    exe_path = &quot;未知&quot;&#10;                    proc_name = &quot;未知&quot;&#10;&#10;                windows.append({&#10;                    &quot;hwnd&quot;: hwnd,&#10;                    &quot;title&quot;: title,&#10;                    &quot;width&quot;: width,&#10;                    &quot;height&quot;: height,&#10;                    &quot;size&quot;: width * height,&#10;                    &quot;exe_path&quot;: exe_path,&#10;                    &quot;process&quot;: proc_name&#10;                })&#10;&#10;    win32gui.EnumWindows(callback, None)&#10;&#10;    # 按窗口尺寸排序，筛选出符合最小尺寸条件的窗口&#10;    suitable_windows = [w for w in windows if w[&quot;width&quot;] &gt;= min_width and w[&quot;height&quot;] &gt;= min_height]&#10;&#10;    if suitable_windows:&#10;        # 按尺寸降序排序，选择最大的窗口&#10;        suitable_windows.sort(key=lambda w: w[&quot;size&quot;], reverse=True)&#10;        game_window_hwnd = suitable_windows[0][&quot;hwnd&quot;]&#10;        print(f&quot;已找到游戏窗口: '{suitable_windows[0]['title']}'&quot;)&#10;        print(f&quot;窗口大小: {suitable_windows[0]['width']}x{suitable_windows[0]['height']}&quot;)&#10;        print(f&quot;进程: {suitable_windows[0]['process']} ({suitable_windows[0]['exe_path']})&quot;)&#10;        return game_window_hwnd&#10;    elif windows:&#10;        print(f&quot;找到的窗口均小于最小尺寸要求({min_width}x{min_height})，可能为启动器窗口:&quot;)&#10;        for w in windows:&#10;            print(f&quot;- '{w['title']}' ({w['width']}x{w['height']}) - {w['process']}&quot;)&#10;        return 0&#10;    else:&#10;        print(f&quot;未找到包含'{game_name}'的窗口&quot;)&#10;        return 0&#10;&#10;&#10;def set_window_topmost(hwnd):&#10;    &quot;&quot;&quot;&#10;    设置窗口置顶，如果窗口最小化则先恢复&#10;&#10;    参数:&#10;        hwnd: int - 窗口句柄&#10;&#10;    返回:&#10;        bool: 设置成功返回True，失败返回False&#10;&#10;    功能:&#10;        1. 检查窗口是否最小化，如果是则先恢复&#10;        2. 调用Win32 API设置窗口为置顶状态&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # 检查窗口是否最小化&#10;        if win32gui.IsIconic(hwnd):&#10;            # 先恢复窗口&#10;            print(&quot;窗口已最小化，先恢复窗口&quot;)&#10;            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)&#10;            # 给窗口一点时间恢复&#10;            time.sleep(0.3)&#10;&#10;        # 设置窗口置顶&#10;        win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0,&#10;                              win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)&#10;        print(&quot;已将窗口设置为置顶&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;设置窗口置顶失败: {e}&quot;)&#10;        return False&#10;&#10;&#10;def unset_window_topmost(hwnd):&#10;    &quot;&quot;&quot;&#10;    取消窗口置顶&#10;&#10;    参数:&#10;        hwnd: int - 窗口句柄&#10;&#10;    返回:&#10;        bool: 设置成功返回True，失败返回False&#10;&#10;    功能:&#10;        调用Win32 API取消窗口的置顶状态，使其恢复普通窗口层级&#10;    &quot;&quot;&quot;&#10;    try:&#10;        win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0,&#10;                              win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)&#10;        print(&quot;已取消窗口置顶&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;取消窗口置顶失败: {e}&quot;)&#10;        return False&#10;&#10;&#10;def toggle_pause():&#10;    &quot;&quot;&quot;&#10;    切换脚本暂停状态，同时控制窗口置顶状态&#10;&#10;    功能:&#10;        1. 切换全局暂停标志&#10;        2. 根据暂停状态设置或取消窗口置顶&#10;        3. 输出暂停/恢复状态信息&#10;    &quot;&quot;&quot;&#10;    global paused, game_window_hwnd&#10;    paused = not paused&#10;&#10;    if paused:&#10;        print(&quot;脚本已暂停&quot;)&#10;        # 暂停时取消窗口置顶&#10;        # noinspection PyUnreachableCode&#10;        if game_window_hwnd:&#10;            unset_window_topmost(game_window_hwnd)&#10;    else:&#10;        print(&quot;脚本已恢复&quot;)&#10;        # 恢复时重新置顶窗口&#10;        # noinspection PyUnreachableCode&#10;        if game_window_hwnd:&#10;            set_window_topmost(game_window_hwnd)&#10;&#10;&#10;# 监听快捷键 Ctrl+P&#10;keyboard.add_hotkey('ctrl+p', toggle_pause)&#10;&#10;&#10;def view_money(location, region):&#10;    &quot;&quot;&quot;&#10;    识别并返回当前账号拥有的哈夫币数量&#10;&#10;    参数:&#10;        location: tuple - 哈夫币图标位置坐标(x, y)&#10;        region: tuple - 哈夫币数量区域(x, y, width, height)&#10;&#10;    返回:&#10;        int 或 None: 识别到的哈夫币数量，识别失败返回None&#10;    &quot;&quot;&quot;&#10;    # 移动鼠标到哈夫币图标位置，触发显示哈夫币数量的悬浮窗&#10;    pyautogui.moveTo(location)&#10;    time.sleep(0.5)  # 等待悬浮窗完全显示&#10;&#10;    # 截取哈夫币数量区域的图像&#10;    screenshot = pyautogui.screenshot(region=region)&#10;&#10;    # 使用OCR识别图像中的数字，限制识别字符集为数字和逗号&#10;    custom_config = r'--psm 6 -c tessedit_char_whitelist=0123456789,'&#10;    money = pytesseract.image_to_string(screenshot, config=custom_config)&#10;&#10;    try:&#10;        # 输出识别结果并返回处理后的整数值&#10;        print(f&quot;当前哈夫币数量为{money.strip()}&quot;)&#10;        # 移除换行符、空格和逗号，转换为整数&#10;        return int(money.strip().replace(&quot;\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;&quot;))&#10;    except ValueError:&#10;        # 如果转换失败（通常是因为OCR识别不准确），返回None&#10;        return None&#10;&#10;&#10;def is_color_similar(a, b, target_color, threshold=30):&#10;    &quot;&quot;&quot;&#10;    使用 mss 截取 1x1 区域获取像素颜色&#10;    读取失败返回 False。&#10;    &quot;&quot;&quot;&#10;    try:&#10;        with mss.mss() as sct:&#10;            region = {&quot;top&quot;: b, &quot;left&quot;: a, &quot;width&quot;: 1, &quot;height&quot;: 1}&#10;            img = np.array(sct.grab(region))  # BGRA&#10;            bgr = img[0, 0, :3]&#10;            pixel_color = (int(bgr[2]), int(bgr[1]), int(bgr[0]))  # 转 RGB&#10;    except Exception:&#10;        return False&#10;&#10;    dr = pixel_color[0] - target_color[0]&#10;    dg = pixel_color[1] - target_color[1]&#10;    db = pixel_color[2] - target_color[2]&#10;    return (dr * dr + dg * dg + db * db) ** 0.5 &lt; threshold&#10;&#10;&#10;def check_chi(region, content):&#10;    &quot;&quot;&quot;&#10;    识别指定区域内的汉字是否与预期内容匹配&#10;&#10;    参数:&#10;        region: tuple - 截图区域 (x, y, width, height)&#10;        content: str - 预期匹配的中文内容&#10;&#10;    返回:&#10;        bool: 匹配成功返回True，否则返回False&#10;    &quot;&quot;&quot;&#10;    # 截取指定区域&#10;    screenshot = pyautogui.screenshot(region=region)&#10;&#10;    # 使用中文简体模型进行OCR识别&#10;    check_result = pytesseract.image_to_string(screenshot, config='--psm 6', lang='chi_sim')&#10;&#10;    try:&#10;        # 比较OCR结果是否与预期内容完全匹配&#10;        if check_result.strip() == content:&#10;            return True&#10;        return False&#10;    except ValueError:&#10;        # 处理异常情况&#10;        return False&#10;&#10;&#10;def refresh_operation():&#10;    &quot;&quot;&quot;&#10;    刷新交易行状态，防止界面卡顿&#10;&#10;    返回:&#10;        bool: 当且仅当本次确实执行了刷新流程时返回 True，否则 False。&#10;    &quot;&quot;&quot;&#10;    global thread_pause_click, start_time_single&#10;&#10;    # 检查是否达到刷新时间间隔(配置文件默认180秒)&#10;    if time.time() - start_time_single &gt; execution_time_single:&#10;        # 暂停线程&#10;        thread_pause_click = True&#10;&#10;        time.sleep(0.1)&#10;&#10;        # flag用于标记是否已经从全面战场切换回烽火地带模式&#10;        flag = False&#10;&#10;        print(&quot;刷新交易行状态&quot;)&#10;        # 处理各种可能的界面状态，循环直到成功回到交易行界面&#10;        while True:&#10;            time.sleep(0.5)&#10;            if check_chi((814, 477, 19, 21), '为'):&#10;                # 识别到&quot;禁止使用市场...&quot;界面提示，按ESC关闭&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(1771, 362, (234, 235, 235)):&#10;                # 识别到交易行购买子弹的二级界面，按ESC返回一级界面&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(180, 106, (191, 195, 195)) or is_color_similar(180, 106, (81, 84, 85)):&#10;                # 识别到交易行一级界面，按ESC关闭&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(1459, 1043, (67, 70, 72)):&#10;                # 识别到烽火地带开始游戏界面&#10;                if flag:&#10;                    # 如果之前已执行过切换模式操作，返回交易行&#10;                    pyautogui.moveTo(720, 80)  # 移动到交易行按钮位置下方&#10;                    if not is_color_similar(720, 77, (91, 197, 146)):&#10;                        pyautogui.move(0, -20, 0.1)  # 上移选择菜单项&#10;                        time.sleep(0.2)&#10;                        pyautogui.click()&#10;                        time.sleep(0.1)&#10;                        pyautogui.move(0, 20, 0.1)  # 重置鼠标位置&#10;                    time.sleep(0.5)&#10;&#10;                    # 点击收藏一号位，避免界面位移问题&#10;                    for _ in range(3):&#10;                        controller.mouse_click(660, 240)&#10;                        time.sleep(0.2)&#10;                    controller.key_press('esc')&#10;                    time.sleep(0.5)&#10;&#10;                    break  # 成功返回交易行，退出循环&#10;                else:&#10;                    # 否则先离开烽火地带&#10;                    controller.key_press('esc')&#10;&#10;            elif is_color_similar(1415, 1053, (82, 86, 88)):&#10;                # 识别到全面战场开始游戏界面，按ESC离开&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(104, 330, (233, 234, 234)) and is_color_similar(104, 550, (99, 100, 99)):&#10;                # 识别切换模式界面（此时在烽火地带）&#10;                # 通过检查左侧菜单栏的颜色状态来判断当前游戏模式&#10;                pyautogui.moveTo(250, 380)  # 移动到模式选择菜单&#10;                # 切换到全面战场模式&#10;                for _ in range(3):  # 通过多次点击确保成功选择&#10;                    pyautogui.move(0, 20, 0.1)  # 下移选择菜单项&#10;                    time.sleep(0.2)&#10;                    pyautogui.click()&#10;                    time.sleep(0.1)&#10;                    pyautogui.move(0, -20, 0.1)  # 重置鼠标位置&#10;&#10;            elif is_color_similar(104, 330, (88, 88, 89)) and is_color_similar(104, 550, (234, 235, 235)):&#10;                # 识别切换模式界面（此时在全面战场）&#10;                pyautogui.moveTo(250, 380)  # 移动到模式选择菜单&#10;                # 切换到烽火地带模式&#10;                for _ in range(3):  # 通过多次点击确保成功选择&#10;                    pyautogui.move(0, -20, 0.1)  # 上移选择菜单项&#10;                    time.sleep(0.2)&#10;                    pyautogui.click()&#10;                    time.sleep(0.1)&#10;                    pyautogui.move(0, 20, 0.1)  # 重置鼠标位置&#10;                flag = True  # 标记已经执行了从全面战场到烽火地带的切换操作&#10;&#10;        start_time_single = time.time()&#10;        # 恢复线程&#10;        thread_pause_click = False&#10;        return True&#10;&#10;    return False&#10;&#10;&#10;def continuous_click_worker():&#10;    &quot;&quot;&quot;&#10;    连续鼠标点击线程函数&#10;    &#10;    功能:&#10;        以高频率持续点击指定位置&#10;        可通过全局变量暂停和恢复&#10;        用于快速刷新交易行物品列表&#10;    &quot;&quot;&quot;&#10;    global thread_running, thread_pause_click&#10;&#10;    while thread_running:&#10;        # 检查线程是否需要暂停&#10;        if thread_pause_click:&#10;            time.sleep(0.05)  # 暂停状态下降低CPU使用率&#10;            continue&#10;&#10;        controller.mouse_click(x, y)  # 点击当前目标位置&#10;        time.sleep(0.2)  # 点击间隔睡眠7毫秒，频率约每秒100次&#10;&#10;&#10;def run_for_duration(duration_time):&#10;    &quot;&quot;&quot;&#10;    在指定时间内执行交易行监控与操作：&#10;    - 采用并发状态监测 + 消抖（武装/失效/重武装）&#10;    - 保留定期刷新交易行、暂停/恢复连点、界面状态检查、二次检查价格等逻辑&#10;    &quot;&quot;&quot;&#10;    global paused, should_exit, thread_running, thread_pause_click, start_time_single, \&#10;        consumption, initial_money, end_money&#10;&#10;    # 置顶窗口&#10;    hwnd = find_game_window()&#10;    if hwnd:&#10;        set_window_topmost(hwnd)&#10;    else:&#10;        print(&quot;警告: 定时执行开始时未找到游戏窗口，无法置顶&quot;)&#10;&#10;    # 初始资金与定位&#10;    location, region = detect_location.main()&#10;    initial_money = view_money(location, region)&#10;&#10;    start_time = start_time_single = time.time()&#10;&#10;    # 点击收藏一号位，避免界面位移&#10;    for _ in range(3):&#10;        controller.mouse_click(660, 240)&#10;        time.sleep(0.2)&#10;    controller.key_press('esc')&#10;    time.sleep(0.5)&#10;&#10;    # 启动线程：仅连点 (已移除颜色检测线程)&#10;    thread_running = True&#10;    thread_pause_click = False&#10;&#10;    click_thread = threading.Thread(target=continuous_click_worker, daemon=True)&#10;    click_thread.start()&#10;&#10;    # 启动并发状态监测（六位价/暂无/七位分隔符）&#10;    monitor = PurchaseStateMonitor(poll_interval=0.03, rearm_clear_consecutive=1)&#10;    monitor.start()&#10;&#10;    try:&#10;        while time.time() - start_time &lt; duration_time:&#10;            # 暂停控制&#10;            if paused:&#10;                thread_pause_click = True&#10;                while paused:&#10;                    time.sleep(0.1)&#10;                thread_pause_click = False&#10;                continue&#10;&#10;            # 定期刷新交易行&#10;            refreshed = refresh_operation()&#10;            if refreshed:&#10;                monitor.clear_pending() # 清空待处理事件，避免消费到上一次循环的残留事件&#10;&#10;            # 取事件（带短超时，便于循环做其它工作）&#10;            try:&#10;                evt = monitor.get_event(timeout=0.2)&#10;            except queue.Empty:&#10;                continue&#10;&#10;            # 处理事件&#10;            if evt.kind == 'six_digits':&#10;                price = evt.data&#10;                if expected_price_1 &lt;= price &lt;= expected_price_2:&#10;                    print(f&quot;识别到价格{price}&quot;)&#10;                    # 暂停连点，避免干扰购买操作&#10;                    thread_pause_click = True&#10;                    controller.mouse_moveTo(1746, 900)&#10;                    controller.mouse_move(0, 10)&#10;                    controller.mouse_click()&#10;&#10;                    # take_screenshot(price)&#10;                    time.sleep(0.5)&#10;                    thread_pause_click = False&#10;&#10;                controller.key_press('esc')&#10;&#10;            elif evt.kind in ('no_items', 'seven_sep'):&#10;                # 无货或七位分隔符，直接返回&#10;                controller.key_press('esc')&#10;&#10;    finally:&#10;        # 停止监测与线程&#10;        monitor.stop()&#10;        thread_running = False&#10;        click_thread.join(timeout=1.0)&#10;&#10;        # 统计最终消耗&#10;        time.sleep(1)&#10;        location, region = detect_location.main()&#10;        end_money = view_money(location, region)&#10;        if end_money is not None:&#10;            consumption_delta = initial_money - end_money if initial_money is not None else 0&#10;            consumption_total = consumption + consumption_delta&#10;            consumption_str = &quot;{:,}&quot;.format(consumption_total)&#10;        else:&#10;            print(&quot;最终哈夫币数量无法识别&quot;)&#10;            consumption_str = &quot;识别失败&quot;&#10;&#10;        print(f&quot;时间到，总计消耗哈夫币：{consumption_str}&quot;)&#10;        should_exit = True&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;&#10;    主函数，调度整个脚本的执行&#10;&#10;    功能:&#10;        1. 设置定时任务&#10;        2. 等待定时任务执行&#10;        3. 处理退出信号&#10;    &quot;&quot;&quot;&#10;    global game_window_hwnd, should_exit&#10;&#10;    # 查找游戏窗口（在定时执行时置顶）&#10;    game_window_hwnd = find_game_window()&#10;&#10;    # 输出脚本即将执行的时间和持续时长&#10;    print(f&quot;{execution_time}开始执行，执行{duration}秒&quot;)&#10;&#10;    # 设置定时任务，在指定时间执行run_for_duration函数&#10;    schedule.every().day.at(execution_time).do(run_for_duration, duration_time=duration)&#10;&#10;    # 持续运行，直到收到退出信号&#10;    try:&#10;        while not should_exit:&#10;            # 检查并执行到期的定时任务&#10;            schedule.run_pending()&#10;            # 每秒检查一次，降低CPU占用&#10;            time.sleep(1)&#10;    finally:&#10;        # 脚本结束时，取消窗口置顶&#10;        if game_window_hwnd:&#10;            unset_window_topmost(game_window_hwnd)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 创建Tee实例，重定向输出到日志文件&#10;    tee = Tee()&#10;    sys.stdout = tee&#10;&#10;    # 记录当前时间作为日志标题&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;    print(f&quot;\n====== 运行时间: {timestamp} ======\n&quot;)&#10;&#10;    try:&#10;        # 运行主程序&#10;        main()&#10;    finally:&#10;        # 确保线程停止&#10;        thread_running = False&#10;        # 给线程一点时间退出&#10;        time.sleep(0.5)&#10;&#10;        # 关闭日志文件并恢复标准输出&#10;        sys.excepthook = tee.original_excepthook&#10;        sys.stdout = tee.stdout&#10;        tee.file.close()&#10;&#10;        print(f&quot;日志已保存到 {tee.file.name}&quot;)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;三角洲倒子弹脚本&#10;功能：通过高频刷新交易行界面监控装备价格，截取低价装备购买&#10;作者：wcl&#10;最后更新：2025.8.20&#10;&quot;&quot;&quot;&#10;import mss&#10;import numpy as np&#10;import win32gui&#10;import win32process&#10;import psutil&#10;import win32con&#10;from PIL import ImageDraw&#10;import detect_money&#10;import detect_location&#10;import threading&#10;import queue&#10;import time&#10;import schedule&#10;import configparser&#10;import pyautogui&#10;import pytesseract&#10;import os&#10;import sys&#10;import datetime&#10;import keyboard&#10;from dataclasses import dataclass&#10;from mouse_keyboard_controller import MouseKeyboardController&#10;&#10;controller = MouseKeyboardController()&#10;&#10;# 获取脚本所在目录&#10;BASE_DIR = os.path.dirname(os.path.abspath(__file__))&#10;# 使用相对路径读取配置文件&#10;config_path = os.path.join(BASE_DIR, 'config.ini')&#10;&#10;config = configparser.ConfigParser()&#10;# 显式指定 UTF-8 编码来读取文件&#10;with open(config_path, encoding='utf-8') as f:&#10;    config.read_file(f)&#10;&#10;# --- 配置参数 ---&#10;game_name = config['window']['game_window_name']  # 游戏窗口名称&#10;min_width = int(config['window']['min_width'])  # 最小窗口宽度&#10;min_height = int(config['window']['min_height'])  # 最小窗口高度&#10;expected_price = config['limit']['expected_price'].split(',')&#10;expected_price_1 = int(expected_price[0])  # 价格下限&#10;expected_price_2 = int(expected_price[1])  # 价格上限&#10;x = int(config['click_location']['x'])  # 收藏物品X坐标&#10;y = int(config['click_location']['y'])  # 收藏物品Y坐标&#10;execution_time = config['schedule']['execution_time']  # 脚本执行时间&#10;execution_time_single = int(config['schedule']['execution_time_single'])  # 单次执行时长(秒)&#10;duration = int(config['schedule']['duration'])  # 总运行时长(秒)&#10;&#10;# --- 控制标志 ---&#10;paused = False  # 控制脚本暂停/恢复&#10;should_exit = False  # 标记主程序的运行与结束&#10;thread_pause_click = False  # 控制连点线程的暂停&#10;thread_running = True  # 控制主程序运行与结束时子线程的运行与结束&#10;game_window_hwnd = None  # 游戏主窗口句柄&#10;&#10;# --- 线程通信 ---&#10;color_check_result = False  # 线程安全变量，存储颜色检测结果&#10;color_check_lock = threading.Lock()  # 颜色检测结果的线程锁&#10;&#10;# --- 统计数据 ---&#10;start_time_single = time.time()  # 计时器初始值&#10;consumption = initial_money = end_money = 0  # 消耗的哈夫币统计&#10;&#10;&#10;class Tee:&#10;    &quot;&quot;&quot;&#10;    同时将输出重定向到控制台和日志文件的类&#10;&#10;    实现了标准输出的重定向，同时捕获未处理的异常并记录到日志文件&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, filename=None):&#10;        &quot;&quot;&quot;&#10;        初始化Tee对象，设置日志文件路径并重定向标准输出&#10;&#10;        参数:&#10;            filename: str - 日志文件名，如果为None则使用当前时间戳命名&#10;        &quot;&quot;&quot;&#10;        log_dir = os.path.join(BASE_DIR, 'logs')  # 指定日志保存路径&#10;        os.makedirs(log_dir, exist_ok=True)  # 确保目录存在&#10;&#10;        # 如果没有提供文件名，则以当前时间命名&#10;        if filename is None:&#10;            timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d_%H-%M-%S&quot;)&#10;            filename = f&quot;log_{timestamp}.txt&quot;&#10;&#10;        self.file = open(os.path.join(log_dir, filename), &quot;a&quot;, encoding=&quot;utf-8&quot;)  # 追加模式&#10;        self.stdout = sys.stdout&#10;        sys.stdout = self&#10;&#10;        # 设置异常钩子，捕获未处理的异常&#10;        self.original_excepthook = sys.excepthook&#10;        sys.excepthook = self.exception_handler&#10;&#10;    def write(self, message):&#10;        &quot;&quot;&quot;&#10;        写入消息到标准输出和日志文件&#10;&#10;        参数:&#10;            message: str - 要写入的消息&#10;        &quot;&quot;&quot;&#10;        # 获取当前时间戳，精确到毫秒&#10;        timestamp = f&quot;[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]}] &quot;&#10;        # 在每条日志前添加时间戳&#10;        if message.strip():  # 仅对非空行添加时间戳&#10;            message = f&quot;{timestamp}{message}&quot;  # 确保时间戳格式完整&#10;        self.stdout.write(message)  # 在 CMD 窗口打印&#10;        self.file.write(message)  # 同时写入文件&#10;        self.flush()  # 确保日志信息立即写入文件&#10;&#10;    def flush(self):&#10;        &quot;&quot;&quot;确保日志即时写入文件和标准输出&quot;&quot;&quot;&#10;        self.stdout.flush()&#10;        self.file.flush()&#10;&#10;    def exception_handler(self, exc_type, exc_value, exc_traceback):&#10;        &quot;&quot;&quot;&#10;        处理未捕获的异常，将异常信息记录到日志文件&#10;&#10;        参数:&#10;            exc_type: 异常类型&#10;            exc_value: 异常值&#10;            exc_traceback: 异常的堆栈跟踪&#10;        &quot;&quot;&quot;&#10;        # 将异常信息格式化为字符串&#10;        import traceback&#10;        exception_str = &quot;&quot;.join(traceback.format_exception(exc_type, exc_value, exc_traceback))&#10;        # 写入日志&#10;        self.write(&quot;\n*** 捕获到未处理的异常 ***\n&quot;)&#10;        self.write(f&quot;{exception_str}\n&quot;)&#10;        self.write(&quot;*** 异常信息结束 ***\n&quot;)&#10;        self.flush()&#10;        # 调用原始异常处理器&#10;        self.original_excepthook(exc_type, exc_value, exc_traceback)&#10;&#10;&#10;@dataclass(frozen=True)&#10;class PurchaseEvent:&#10;    kind: str              # 'six_digits' | 'no_items' | 'seven_sep'&#10;    data: int | None = None&#10;&#10;class PurchaseStateMonitor:&#10;    &quot;&quot;&quot;&#10;    并行监测三种状态，任一命中产生事件；随后进入失效态，&#10;    待检测到“三种状态均不命中”连续 N 次后再重武装。&#10;    &quot;&quot;&quot;&#10;    def __init__(self, poll_interval: float = 0.03, rearm_clear_consecutive: int = 1):&#10;        self.poll_interval = poll_interval&#10;        self.rearm_clear_consecutive = rearm_clear_consecutive&#10;&#10;        self._stop = threading.Event()&#10;        self._armed = True&#10;        self._armed_lock = threading.Lock()&#10;&#10;        self._present = {'six': False, 'no': False, 'seven': False}&#10;        self._present_lock = threading.Lock()&#10;&#10;        self._q: &quot;queue.Queue[PurchaseEvent]&quot; = queue.Queue(maxsize=1)&#10;        self._threads: list[threading.Thread] = []&#10;&#10;    def start(self):&#10;        self._threads = [&#10;            threading.Thread(target=self._watch_six_digits, daemon=True),&#10;            threading.Thread(target=self._watch_no_items, daemon=True),&#10;            threading.Thread(target=self._watch_seven_sep, daemon=True),&#10;            threading.Thread(target=self._watch_rearm_all_clear, daemon=True),&#10;        ]&#10;        for t in self._threads:&#10;            t.start()&#10;&#10;    def stop(self):&#10;        self._stop.set()&#10;        for t in self._threads:&#10;            t.join(timeout=1.0)&#10;&#10;    def get_event(self, timeout: float | None = None) -&gt; PurchaseEvent:&#10;        return self._q.get(timeout=timeout)&#10;&#10;&#10;    def clear_pending(self) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        清空待处理事件，避免消费到上一次循环的残留事件。&#10;        采用与投递相同的锁以避免竞态。&#10;        &quot;&quot;&quot;&#10;        with self._armed_lock:&#10;            while True:&#10;                try:&#10;                    self._q.get_nowait()&#10;                except queue.Empty:&#10;                    break&#10;    def _emit_if_armed(self, evt: PurchaseEvent) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        若当前处于武装态，投递事件并转入失效态；返回 True 表示成功投递（可打印一次性日志）。&#10;        &quot;&quot;&quot;&#10;        with self._armed_lock:&#10;            if not self._armed:&#10;                return False&#10;            # 清理可能残留的旧事件，确保只保留最新命中的&#10;            while not self._q.empty():&#10;                try:&#10;                    self._q.get_nowait()&#10;                except queue.Empty:&#10;                    break&#10;            self._q.put(evt)&#10;            self._armed = False&#10;            return True&#10;&#10;    def _watch_six_digits(self):&#10;        while not self._stop.is_set():&#10;            val = detect_money.main()&#10;            hit = isinstance(val, int) and 100000 &lt;= val &lt;= 999999&#10;            with self._present_lock:&#10;                self._present['six'] = hit&#10;            if hit:&#10;                self._emit_if_armed(PurchaseEvent('six_digits', val))&#10;            time.sleep(self.poll_interval)&#10;&#10;    def _watch_no_items(self):&#10;        while not self._stop.is_set():&#10;            hit = is_color_similar(1630, 889, (75, 79, 82), 10)&#10;            with self._present_lock:&#10;                self._present['no'] = hit&#10;            if hit:&#10;                self._emit_if_armed(PurchaseEvent('no_items', None))&#10;            time.sleep(self.poll_interval)&#10;&#10;    def _watch_seven_sep(self):&#10;        while not self._stop.is_set():&#10;            hit = is_color_similar(313, 193, (179, 181, 183), 10)&#10;            with self._present_lock:&#10;                self._present['seven'] = hit&#10;            if hit:&#10;                self._emit_if_armed(PurchaseEvent('seven_sep', None))&#10;            time.sleep(self.poll_interval)&#10;&#10;    def _watch_rearm_all_clear(self):&#10;        clear_cnt = 0&#10;        while not self._stop.is_set():&#10;            with self._armed_lock:&#10;                armed = self._armed&#10;            if armed:&#10;                clear_cnt = 0&#10;                time.sleep(self.poll_interval)&#10;                continue&#10;&#10;            with self._present_lock:&#10;                any_hit = self._present['six'] or self._present['no'] or self._present['seven']&#10;&#10;            if not any_hit:&#10;                clear_cnt += 1&#10;                if clear_cnt &gt;= self.rearm_clear_consecutive:&#10;                    with self._armed_lock:&#10;                        self._armed = True&#10;                    clear_cnt = 0&#10;            else:&#10;                clear_cnt = 0&#10;            time.sleep(self.poll_interval)&#10;&#10;&#10;def take_screenshot(price):&#10;    &quot;&quot;&quot;&#10;    截取当前屏幕并保存，包含鼠标指针位置&#10;&#10;    参数:&#10;        price: int - 当前识别到的价格，将添加到文件名中&#10;&#10;    功能:&#10;        1. 创建包含时间戳和价格的文件名&#10;        2. 截取全屏&#10;        3. 在截图上标记当前鼠标位置&#10;        4. 保存截图到指定目录&#10;    &quot;&quot;&quot;&#10;    # 获取当前时间戳，精确到毫秒&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d_%H-%M-%S.%f&quot;)[:-3]&#10;    # 将价格添加到文件名中&#10;    screenshot_path = os.path.join(BASE_DIR, 'screenshots', f&quot;screenshot_{timestamp}_price_{price}.png&quot;)&#10;    os.makedirs(os.path.dirname(screenshot_path), exist_ok=True)  # 确保目录存在&#10;&#10;    # 使用pyautogui截取全屏&#10;    screenshot = pyautogui.screenshot()&#10;&#10;    # 获取鼠标位置，用于在截图上标记鼠标位置&#10;    cursor_pos = win32gui.GetCursorPos()&#10;&#10;    # 获取当前使用的鼠标光标&#10;    cursor_info = win32gui.GetCursorInfo()&#10;    cursor = cursor_info[1]  # 获取光标句柄&#10;&#10;    # 获取光标信息&#10;    if cursor:&#10;        try:&#10;            # 将光标绘制到截图上&#10;            draw = ImageDraw.Draw(screenshot)&#10;&#10;            # 绘制一个红色圆点表示光标位置，便于后续分析问题&#10;            draw.ellipse((cursor_pos[0] - 2, cursor_pos[1] - 2,&#10;                          cursor_pos[0] + 2, cursor_pos[1] + 2), fill='red')&#10;&#10;        except Exception as e:&#10;            print(f&quot;无法添加鼠标指针: {str(e)}&quot;)&#10;&#10;    # 保存图片&#10;    screenshot.save(screenshot_path)&#10;    print(f&quot;全屏幕截屏(含鼠标指针)已保存到 {screenshot_path}&quot;)&#10;&#10;&#10;def get_window_normal_size(hwnd):&#10;    &quot;&quot;&quot;&#10;    获取窗口的正常尺寸，即使它当前是最小化的&#10;&#10;    参数:&#10;        hwnd: int - 窗口句柄&#10;&#10;    返回:&#10;        tuple: (width, height) - 窗口的宽度和高度&#10;&#10;    功能:&#10;        1. 检查窗口是否最小化&#10;        2. 如果是最小化状态，获取其正常位置信息&#10;        3. 如果不是最小化状态，直接获取当前尺寸&#10;        4. 返回窗口的宽度和高度&#10;    &quot;&quot;&quot;&#10;    minimized = win32gui.IsIconic(hwnd)&#10;&#10;    if minimized:&#10;        # 获取窗口的正常位置信息（即使窗口是最小化的）&#10;        window_placement = win32gui.GetWindowPlacement(hwnd)&#10;        normal_rect = window_placement[4]  # normalPosition属性&#10;        width = normal_rect[2] - normal_rect[0]&#10;        height = normal_rect[3] - normal_rect[1]&#10;        return width, height&#10;    else:&#10;        # 窗口未最小化，直接获取当前尺寸&#10;        rect = win32gui.GetWindowRect(hwnd)&#10;        width = rect[2] - rect[0]&#10;        height = rect[3] - rect[1]&#10;        return width, height&#10;&#10;&#10;def find_game_window():&#10;    &quot;&quot;&quot;&#10;    查找游戏窗口，通过尺寸区分游戏本体和启动器&#10;&#10;    返回:&#10;        int: 游戏窗口句柄，若未找到则返回0&#10;&#10;    功能:&#10;        1. 枚举所有窗口，筛选出标题包含游戏名称的窗口&#10;        2. 获取这些窗口的尺寸和进程信息&#10;        3. 根据最小尺寸要求筛选出符合条件的窗口&#10;        4. 选择尺寸最大的窗口作为游戏主窗口&#10;    &quot;&quot;&quot;&#10;    global game_window_hwnd&#10;&#10;    windows = []&#10;&#10;    def callback(hwnd, extra):&#10;        if win32gui.IsWindowVisible(hwnd):&#10;            title = win32gui.GetWindowText(hwnd)&#10;            if game_name.lower() in title.lower():&#10;                # 获取窗口正常尺寸（即使最小化）&#10;                width, height = get_window_normal_size(hwnd)&#10;                # 获取进程信息&#10;                try:&#10;                    pid = win32process.GetWindowThreadProcessId(hwnd)[1]&#10;                    process = psutil.Process(pid)&#10;                    exe_path = process.exe()&#10;                    proc_name = process.name()&#10;                except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                    exe_path = &quot;未知&quot;&#10;                    proc_name = &quot;未知&quot;&#10;&#10;                windows.append({&#10;                    &quot;hwnd&quot;: hwnd,&#10;                    &quot;title&quot;: title,&#10;                    &quot;width&quot;: width,&#10;                    &quot;height&quot;: height,&#10;                    &quot;size&quot;: width * height,&#10;                    &quot;exe_path&quot;: exe_path,&#10;                    &quot;process&quot;: proc_name&#10;                })&#10;&#10;    win32gui.EnumWindows(callback, None)&#10;&#10;    # 按窗口尺寸排序，筛选出符合最小尺寸条件的窗口&#10;    suitable_windows = [w for w in windows if w[&quot;width&quot;] &gt;= min_width and w[&quot;height&quot;] &gt;= min_height]&#10;&#10;    if suitable_windows:&#10;        # 按尺寸降序排序，选择最大的窗口&#10;        suitable_windows.sort(key=lambda w: w[&quot;size&quot;], reverse=True)&#10;        game_window_hwnd = suitable_windows[0][&quot;hwnd&quot;]&#10;        print(f&quot;已找到游戏窗口: '{suitable_windows[0]['title']}'&quot;)&#10;        print(f&quot;窗口大小: {suitable_windows[0]['width']}x{suitable_windows[0]['height']}&quot;)&#10;        print(f&quot;进程: {suitable_windows[0]['process']} ({suitable_windows[0]['exe_path']})&quot;)&#10;        return game_window_hwnd&#10;    elif windows:&#10;        print(f&quot;找到的窗口均小于最小尺寸要求({min_width}x{min_height})，可能为启动器窗口:&quot;)&#10;        for w in windows:&#10;            print(f&quot;- '{w['title']}' ({w['width']}x{w['height']}) - {w['process']}&quot;)&#10;        return 0&#10;    else:&#10;        print(f&quot;未找到包含'{game_name}'的窗口&quot;)&#10;        return 0&#10;&#10;&#10;def set_window_topmost(hwnd):&#10;    &quot;&quot;&quot;&#10;    设置窗口置顶，如果窗口最小化则先恢复&#10;&#10;    参数:&#10;        hwnd: int - 窗口句柄&#10;&#10;    返回:&#10;        bool: 设置成功返回True，失败返回False&#10;&#10;    功能:&#10;        1. 检查窗口是否最小化，如果是则先恢复&#10;        2. 调用Win32 API设置窗口为置顶状态&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # 检查窗口是否最小化&#10;        if win32gui.IsIconic(hwnd):&#10;            # 先恢复窗口&#10;            print(&quot;窗口已最小化，先恢复窗口&quot;)&#10;            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)&#10;            # 给窗口一点时间恢复&#10;            time.sleep(0.3)&#10;&#10;        # 设置窗口置顶&#10;        win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0,&#10;                              win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)&#10;        print(&quot;已将窗口设置为置顶&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;设置窗口置顶失败: {e}&quot;)&#10;        return False&#10;&#10;&#10;def unset_window_topmost(hwnd):&#10;    &quot;&quot;&quot;&#10;    取消窗口置顶&#10;&#10;    参数:&#10;        hwnd: int - 窗口句柄&#10;&#10;    返回:&#10;        bool: 设置成功返回True，失败返回False&#10;&#10;    功能:&#10;        调用Win32 API取消窗口的置顶状态，使其恢复普通窗口层级&#10;    &quot;&quot;&quot;&#10;    try:&#10;        win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0,&#10;                              win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)&#10;        print(&quot;已取消窗口置顶&quot;)&#10;        return True&#10;    except Exception as e:&#10;        print(f&quot;取消窗口置顶失败: {e}&quot;)&#10;        return False&#10;&#10;&#10;def toggle_pause():&#10;    &quot;&quot;&quot;&#10;    切换脚本暂停状态，同时控制窗口置顶状态&#10;&#10;    功能:&#10;        1. 切换全局暂停标志&#10;        2. 根据暂停状态设置或取消窗口置顶&#10;        3. 输出暂停/恢复状态信息&#10;    &quot;&quot;&quot;&#10;    global paused, game_window_hwnd&#10;    paused = not paused&#10;&#10;    if paused:&#10;        print(&quot;脚本已暂停&quot;)&#10;        # 暂停时取消窗口置顶&#10;        # noinspection PyUnreachableCode&#10;        if game_window_hwnd:&#10;            unset_window_topmost(game_window_hwnd)&#10;    else:&#10;        print(&quot;脚本已恢复&quot;)&#10;        # 恢复时重新置顶窗口&#10;        # noinspection PyUnreachableCode&#10;        if game_window_hwnd:&#10;            set_window_topmost(game_window_hwnd)&#10;&#10;&#10;# 监听快捷键 Ctrl+P&#10;keyboard.add_hotkey('ctrl+p', toggle_pause)&#10;&#10;&#10;def view_money(location, region):&#10;    &quot;&quot;&quot;&#10;    识别并返回当前账号拥有的哈夫币数量&#10;&#10;    参数:&#10;        location: tuple - 哈夫币图标位置坐标(x, y)&#10;        region: tuple - 哈夫币数量区域(x, y, width, height)&#10;&#10;    返回:&#10;        int 或 None: 识别到的哈夫币数量，识别失败返回None&#10;    &quot;&quot;&quot;&#10;    # 移动鼠标到哈夫币图标位置，触发显示哈夫币数量的悬浮窗&#10;    pyautogui.moveTo(location)&#10;    time.sleep(0.5)  # 等待悬浮窗完全显示&#10;&#10;    # 截取哈夫币数量区域的图像&#10;    screenshot = pyautogui.screenshot(region=region)&#10;&#10;    # 使用OCR识别图像中的数字，限制识别字符集为数字和逗号&#10;    custom_config = r'--psm 6 -c tessedit_char_whitelist=0123456789,'&#10;    money = pytesseract.image_to_string(screenshot, config=custom_config)&#10;&#10;    try:&#10;        # 输出识别结果并返回处理后的整数值&#10;        print(f&quot;当前哈夫币数量为{money.strip()}&quot;)&#10;        # 移除换行符、空格和逗号，转换为整数&#10;        return int(money.strip().replace(&quot;\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;&quot;))&#10;    except ValueError:&#10;        # 如果转换失败（通常是因为OCR识别不准确），返回None&#10;        return None&#10;&#10;&#10;def is_color_similar(a, b, target_color, threshold=30):&#10;    &quot;&quot;&quot;&#10;    使用 mss 截取 1x1 区域获取像素颜色&#10;    读取失败返回 False。&#10;    &quot;&quot;&quot;&#10;    try:&#10;        with mss.mss() as sct:&#10;            region = {&quot;top&quot;: b, &quot;left&quot;: a, &quot;width&quot;: 1, &quot;height&quot;: 1}&#10;            img = np.array(sct.grab(region))  # BGRA&#10;            bgr = img[0, 0, :3]&#10;            pixel_color = (int(bgr[2]), int(bgr[1]), int(bgr[0]))  # 转 RGB&#10;    except Exception:&#10;        return False&#10;&#10;    dr = pixel_color[0] - target_color[0]&#10;    dg = pixel_color[1] - target_color[1]&#10;    db = pixel_color[2] - target_color[2]&#10;    return (dr * dr + dg * dg + db * db) ** 0.5 &lt; threshold&#10;&#10;&#10;def check_chi(region, content):&#10;    &quot;&quot;&quot;&#10;    识别指定区域内的汉字是否与预期内容匹配&#10;&#10;    参数:&#10;        region: tuple - 截图区域 (x, y, width, height)&#10;        content: str - 预期匹配的中文内容&#10;&#10;    返回:&#10;        bool: 匹配成功返回True，否则返回False&#10;    &quot;&quot;&quot;&#10;    # 截取指定区域&#10;    screenshot = pyautogui.screenshot(region=region)&#10;&#10;    # 使用中文简体模型进行OCR识别&#10;    check_result = pytesseract.image_to_string(screenshot, config='--psm 6', lang='chi_sim')&#10;&#10;    try:&#10;        # 比较OCR结果是否与预期内容完全匹配&#10;        if check_result.strip() == content:&#10;            return True&#10;        return False&#10;    except ValueError:&#10;        # 处理异常情况&#10;        return False&#10;&#10;&#10;def refresh_operation():&#10;    &quot;&quot;&quot;&#10;    刷新交易行状态，防止界面卡顿&#10;&#10;    返回:&#10;        bool: 当且仅当本次确实执行了刷新流程时返回 True，否则 False。&#10;    &quot;&quot;&quot;&#10;    global thread_pause_click, start_time_single&#10;&#10;    # 检查是否达到刷新时间间隔(配置文件默认180秒)&#10;    if time.time() - start_time_single &gt; execution_time_single:&#10;        # 暂停线程&#10;        thread_pause_click = True&#10;&#10;        time.sleep(0.1)&#10;&#10;        # flag用于标记是否已经从全面战场切换回烽火地带模式&#10;        flag = False&#10;&#10;        print(&quot;刷新交易行状态&quot;)&#10;        # 处理各种可能的界面状态，循环直到成功回到交易行界面&#10;        while True:&#10;            time.sleep(0.5)&#10;            if check_chi((814, 477, 19, 21), '为'):&#10;                # 识别到&quot;禁止使用市场...&quot;界面提示，按ESC关闭&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(1771, 362, (234, 235, 235)):&#10;                # 识别到交易行购买子弹的二级界面，按ESC返回一级界面&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(180, 106, (191, 195, 195)) or is_color_similar(180, 106, (81, 84, 85)):&#10;                # 识别到交易行一级界面，按ESC关闭&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(1459, 1043, (67, 70, 72)):&#10;                # 识别到烽火地带开始游戏界面&#10;                if flag:&#10;                    # 如果之前已执行过切换模式操作，返回交易行&#10;                    pyautogui.moveTo(720, 80)  # 移动到交易行按钮位置下方&#10;                    if not is_color_similar(720, 77, (91, 197, 146)):&#10;                        pyautogui.move(0, -20, 0.1)  # 上移选择菜单项&#10;                        time.sleep(0.2)&#10;                        pyautogui.click()&#10;                        time.sleep(0.1)&#10;                        pyautogui.move(0, 20, 0.1)  # 重置鼠标位置&#10;                    time.sleep(0.5)&#10;&#10;                    # 点击收藏一号位，避免界面位移问题&#10;                    for _ in range(3):&#10;                        controller.mouse_click(660, 240)&#10;                        time.sleep(0.2)&#10;                    controller.key_press('esc')&#10;                    time.sleep(0.5)&#10;&#10;                    break  # 成功返回交易行，退出循环&#10;                else:&#10;                    # 否则先离开烽火地带&#10;                    controller.key_press('esc')&#10;&#10;            elif is_color_similar(1415, 1053, (82, 86, 88)):&#10;                # 识别到全面战场开始游戏界面，按ESC离开&#10;                controller.key_press('esc')&#10;&#10;            elif is_color_similar(104, 330, (233, 234, 234)) and is_color_similar(104, 550, (99, 100, 99)):&#10;                # 识别切换模式界面（此时在烽火地带）&#10;                # 通过检查左侧菜单栏的颜色状态来判断当前游戏模式&#10;                pyautogui.moveTo(250, 380)  # 移动到模式选择菜单&#10;                # 切换到全面战场模式&#10;                for _ in range(3):  # 通过多次点击确保成功选择&#10;                    pyautogui.move(0, 20, 0.1)  # 下移选择菜单项&#10;                    time.sleep(0.2)&#10;                    pyautogui.click()&#10;                    time.sleep(0.1)&#10;                    pyautogui.move(0, -20, 0.1)  # 重置鼠标位置&#10;&#10;            elif is_color_similar(104, 330, (88, 88, 89)) and is_color_similar(104, 550, (234, 235, 235)):&#10;                # 识别切换模式界面（此时在全面战场）&#10;                pyautogui.moveTo(250, 380)  # 移动到模式选择菜单&#10;                # 切换到烽火地带模式&#10;                for _ in range(3):  # 通过多次点击确保成功选择&#10;                    pyautogui.move(0, -20, 0.1)  # 上移选择菜单项&#10;                    time.sleep(0.2)&#10;                    pyautogui.click()&#10;                    time.sleep(0.1)&#10;                    pyautogui.move(0, 20, 0.1)  # 重置鼠标位置&#10;                flag = True  # 标记已经执行了从全面战场到烽火地带的切换操作&#10;&#10;        start_time_single = time.time()&#10;        # 恢复线程&#10;        thread_pause_click = False&#10;        return True&#10;&#10;    return False&#10;&#10;&#10;def continuous_click_worker():&#10;    &quot;&quot;&quot;&#10;    连续鼠标点击线程函数&#10;    &#10;    功能:&#10;        以高频率持续点击指定位置&#10;        可通过全局变量暂停和恢复&#10;        用于快速刷新交易行物品列表&#10;    &quot;&quot;&quot;&#10;    global thread_running, thread_pause_click&#10;&#10;    while thread_running:&#10;        # 检查线程是否需要暂停&#10;        if thread_pause_click:&#10;            time.sleep(0.05)  # 暂停状态下降低CPU使用率&#10;            continue&#10;&#10;        controller.mouse_click(x, y)  # 点击当前目标位置&#10;        time.sleep(0.2)  # 点击间隔睡眠7毫秒，频率约每秒100次&#10;&#10;&#10;def run_for_duration(duration_time):&#10;    &quot;&quot;&quot;&#10;    在指定时间内执行交易行监控与操作：&#10;    - 采用并发状态监测 + 消抖（武装/失效/重武装）&#10;    - 保留定期刷新交易行、暂停/恢复连点、界面状态检查、二次检查价格等逻辑&#10;    &quot;&quot;&quot;&#10;    global paused, should_exit, thread_running, thread_pause_click, start_time_single, \&#10;        consumption, initial_money, end_money&#10;&#10;    # 置顶窗口&#10;    hwnd = find_game_window()&#10;    if hwnd:&#10;        set_window_topmost(hwnd)&#10;    else:&#10;        print(&quot;警告: 定时执行开始时未找到游戏窗口，无法置顶&quot;)&#10;&#10;    # 初始资金与定位&#10;    location, region = detect_location.main()&#10;    initial_money = view_money(location, region)&#10;&#10;    start_time = start_time_single = time.time()&#10;&#10;    # 点击收藏一号位，避免界面位移&#10;    for _ in range(3):&#10;        controller.mouse_click(660, 240)&#10;        time.sleep(0.2)&#10;    controller.key_press('esc')&#10;    time.sleep(0.5)&#10;&#10;    # 启动线程：仅连点 (已移除颜色检测线程)&#10;    thread_running = True&#10;    thread_pause_click = False&#10;&#10;    click_thread = threading.Thread(target=continuous_click_worker, daemon=True)&#10;    click_thread.start()&#10;&#10;    # 启动并发状态监测（六位价/暂无/七位分隔符）&#10;    monitor = PurchaseStateMonitor(poll_interval=0.03, rearm_clear_consecutive=1)&#10;    monitor.start()&#10;&#10;    try:&#10;        while time.time() - start_time &lt; duration_time:&#10;            # 暂停控制&#10;            if paused:&#10;                thread_pause_click = True&#10;                while paused:&#10;                    time.sleep(0.1)&#10;                thread_pause_click = False&#10;                continue&#10;&#10;            # 定期刷新交易行&#10;            refreshed = refresh_operation()&#10;            if refreshed:&#10;                monitor.clear_pending() # 清空待处理事件，避免消费到上一次循环的残留事件&#10;&#10;            # 取事件（带短超时，便于循环做其它工作）&#10;            try:&#10;                evt = monitor.get_event(timeout=0.2)&#10;            except queue.Empty:&#10;                continue&#10;&#10;            # 处理事件&#10;            if evt.kind == 'six_digits':&#10;                price = evt.data&#10;                if expected_price_1 &lt;= price &lt;= expected_price_2:&#10;                    print(f&quot;识别到价格{price}&quot;)&#10;                    # 暂停连点，避免干扰购买操作&#10;                    thread_pause_click = True&#10;                    controller.mouse_moveTo(1746, 900)&#10;                    controller.mouse_move(0, 10)&#10;                    controller.mouse_click()&#10;&#10;                    # take_screenshot(price)&#10;                    time.sleep(0.5)&#10;                    thread_pause_click = False&#10;&#10;                controller.key_press('esc')&#10;&#10;            elif evt.kind in ('no_items', 'seven_sep'):&#10;                # 无货或七位分隔符，直接返回&#10;                controller.key_press('esc')&#10;&#10;    finally:&#10;        # 停止监测与线程&#10;        monitor.stop()&#10;        thread_running = False&#10;        click_thread.join(timeout=1.0)&#10;&#10;        # 统计最终消耗&#10;        time.sleep(1)&#10;        location, region = detect_location.main()&#10;        end_money = view_money(location, region)&#10;        if end_money is not None:&#10;            consumption_delta = initial_money - end_money if initial_money is not None else 0&#10;            consumption_total = consumption + consumption_delta&#10;            consumption_str = &quot;{:,}&quot;.format(consumption_total)&#10;        else:&#10;            print(&quot;最终哈夫币数量无法识别&quot;)&#10;            consumption_str = &quot;识别失败&quot;&#10;&#10;        print(f&quot;时间到，总计消耗哈夫币：{consumption_str}&quot;)&#10;        should_exit = True&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;&#10;    主函数，调度整个脚本的执行&#10;&#10;    功能:&#10;        1. 设置定时任务&#10;        2. 等待定时任务执行&#10;        3. 处理退出信号&#10;    &quot;&quot;&quot;&#10;    global game_window_hwnd, should_exit&#10;&#10;    # 查找游戏窗口（在定时执行时置顶）&#10;    game_window_hwnd = find_game_window()&#10;&#10;    # 输出脚本即将执行的时间和持续时长&#10;    print(f&quot;{execution_time}开始执行，执行{duration}秒&quot;)&#10;&#10;    # 设置定时任务，在指定时间执行run_for_duration函数&#10;    schedule.every().day.at(execution_time).do(run_for_duration, duration_time=duration)&#10;&#10;    # 持续运行，直到收到退出信号&#10;    try:&#10;        while not should_exit:&#10;            # 检查并执行到期的定时任务&#10;            schedule.run_pending()&#10;            # 每秒检查一次，降低CPU占用&#10;            time.sleep(1)&#10;    finally:&#10;        # 脚本结束时，取消窗口置顶&#10;        if game_window_hwnd:&#10;            unset_window_topmost(game_window_hwnd)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # 创建Tee实例，重定向输出到日志文件&#10;    tee = Tee()&#10;    sys.stdout = tee&#10;&#10;    # 记录当前时间作为日志标题&#10;    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;    print(f&quot;\n====== 运行时间: {timestamp} ======\n&quot;)&#10;&#10;    try:&#10;        # 运行主程序&#10;        main()&#10;    finally:&#10;        # 确保线程停止&#10;        thread_running = False&#10;        # 给线程一点时间退出&#10;        time.sleep(0.5)&#10;&#10;        # 关闭日志文件并恢复标准输出&#10;        sys.excepthook = tee.original_excepthook&#10;        sys.stdout = tee.stdout&#10;        tee.file.close()&#10;&#10;        print(f&quot;日志已保存到 {tee.file.name}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>